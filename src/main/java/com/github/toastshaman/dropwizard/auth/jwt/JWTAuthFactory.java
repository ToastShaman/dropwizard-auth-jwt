package com.github.toastshaman.dropwizard.auth.jwt;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.toastshaman.dropwizard.auth.jwt.model.JsonWebToken;
import com.google.common.base.Optional;

import io.dropwizard.auth.AuthFactory;
import io.dropwizard.auth.AuthenticationException;
import io.dropwizard.auth.Authenticator;

public class JWTAuthFactory<T> extends AuthFactory<JsonWebToken, T> {
	private static final Logger LOGGER = LoggerFactory.getLogger(JWTAuthFactory.class);

	private final JsonWebTokenParser tokenParser;
	private final JsonWebTokenVerifier tokenVerifier;
	private final String realm;
	private String prefix = "bearer";
	private final boolean required;
	private final Class<T> generatedClass;

	private static final String CHALLENGE_FORMAT = "Bearer realm=\"%s\""; 

	/**
	 * Creates a new JWTAuthProvider with the given {@link Authenticator} and realm.
	 *
	 * @param authenticator the authenticator which will take the JWT bearer token and convert
	 *                      them into instances of {@code T}
	 * @param tokenParser   the Json Web Token parser
	 * @param tokenVerifier the Json Web Token signature verifier
	 * @param realm         the name of the authentication realm
	 * @param generatedClass the class generated by this provider
	 */
	public JWTAuthFactory(Authenticator<JsonWebToken, T> authenticator,
			JsonWebTokenParser tokenParser,
			JsonWebTokenVerifier tokenVerifier,
			String realm,
			Class<T> generatedClass) {
		super(authenticator);

		this.tokenParser = tokenParser;
		this.tokenVerifier = tokenVerifier;
		this.realm = realm;
		this.generatedClass = generatedClass;

		this.required = true;
	}

	/**
	 * Creates a new JWTAuthProvider with the given {@link Authenticator} and realm.
	 *
	 * @param authenticator  the authenticator which will take the JWT bearer token and convert
	 *                       them into instances of {@code T}
	 * @param tokenParser    the Json Web Token parser
	 * @param tokenVerifier  the Json Web Token signature verifier
	 * @param realm          the name of the authentication realm
	 * @param required		 true if authentication is required
	 * @param generatedClass the class generated by this provider
	 */
	public JWTAuthFactory(Authenticator<JsonWebToken, T> authenticator,
			JsonWebTokenParser tokenParser,
			JsonWebTokenVerifier tokenVerifier,
			String realm,
			boolean required,
			Class<T> generatedClass) {
		super(authenticator);

		this.tokenParser = tokenParser;
		this.tokenVerifier = tokenVerifier;
		this.realm = realm;
		this.required = required;
		this.generatedClass = generatedClass;
	}	

	@Context
	private HttpServletRequest request;

	public JWTAuthFactory<T> prefix(String prefix) {
		this.prefix = prefix;
		return this;
	}

	@Override
	public AuthFactory<JsonWebToken, T> clone(boolean required) {
		return new JWTAuthFactory<>(authenticator(), this.tokenParser, this.tokenVerifier, this.realm, this.required, this.generatedClass).prefix(prefix);
	}

	@Override
	public void setRequest(HttpServletRequest request) {
		this.request = request;
	}

	@Override
	public T provide() {
		if (request != null) {
			try {
				final String header = request.getHeader(HttpHeaders.AUTHORIZATION);
				if (header != null) {
					final int space = header.indexOf(' ');
					if (space > 0) {
						final String method = header.substring(0, space);
						if (prefix.equalsIgnoreCase(method)) {
							final String rawToken = header.substring(space + 1);

							JsonWebToken token = null;

							try {
								token = tokenParser.parse(rawToken);
								tokenVerifier.verifySignature(token);
							} catch (Exception e) {
								throw new AuthenticationException(e.getMessage(), e);
							}

							final Optional<T> result = authenticator().authenticate(token);

							if (result.isPresent()) {
								return result.get();
							}
						}
					}
				}
			} catch (AuthenticationException e) {
				LOGGER.warn("Error authenticating credentials", e);
				throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
			}
		}

		if (required) {
			final String challenge = String.format(CHALLENGE_FORMAT, realm);
			throw new WebApplicationException(Response.status(Response.Status.UNAUTHORIZED)
					.header(HttpHeaders.WWW_AUTHENTICATE, challenge)
					.entity("Credentials are required to access this resource.")
					.type(MediaType.TEXT_PLAIN_TYPE)
					.build());
		}

		return null;
	}

	@Override
	public Class<T> getGeneratedClass() {
		return generatedClass;
	}
}
